from __future__ import annotations

from typing import TYPE_CHECKING

from .core import LabsObject, UseInternal, FormatDispatcher
from .variables import Expr, CacheOutput, Decl, ExprTypeError, RecursivelyReferenceable, LVariable

if TYPE_CHECKING :
  from .main import LabsBuild

class MetabuildObject(object):
  """
  An object to be output in the metabuild
  """


class BVariable(RecursivelyReferenceable, FormatDispatcher, MetabuildObject):
  """
  Variable appearing in the ninja build file.
  A BVariable can be evaluated several time and its value can be changed
  """
  _repr_attrs = {'name=': str, 'expr=':repr}
  decl_cls:type = None # Assigned by VariableDecl
  
  def __init__(self,  doc:str, build:LabsBuild, name:str, expr:Expr=None):
    super().__init__()
    self.doc = doc
    self.build = build
    self.name = name
    if expr is not None :
      self.expr = Expr(expr)
    
  @classmethod
  def decl(cls, expr:Expr=None, doc=None):
    return cls.decl_cls(expr=expr, doc=doc)

  @classmethod
  def instanciate(cls, decl:Decl, build:LabsBuild, name:str):
    r = cls(decl.doc, build, name, decl.expr)
    build._register_metabuild_object(name, r)
    return r
  
class BVariableDecl(Decl, cls=BVariable):
  _repr_attrs = {'expr=': repr}


class GBVariable(BVariable):
  """
  Global Build variable
  """

  def set_expr(self, expr:Expr):
    if part := next(( part for part in expr.parts if isinstance(part, BVariable) and not isinstance(part, GBVariable) ), None) :
      raise ExprTypeError(f"A {part.__class__.__name__} cannot be part of the expression of a GBVariable. ({repr(part)} assigned to {repr(self)}) ")
    super().set_expr(expr)

class LBVariable(LVariable, GBVariable):
  """
  A LVariable which is also exported in the ninja.build
  """
  
class LBVariableDecl(Decl, cls=LBVariable):
  _repr_attrs = {'type=': repr, 'default_value=': repr}
    
bvariable = GBVariable.decl
lbvariable = LBVariable.decl


    
class AbstractBRVariable(BVariable):
  """
  A BuildRule variable.
  """
  _repr_attrs = {'rule': repr}
  
  def __init__(self, doc:str, rule:BRule, name:str, expr:Expr=None):
    super().__init__(doc, rule._internal.build, name, expr)
    self.rule = rule
  
  @classmethod
  def instanciate(cls, decl:Decl, rule:BRule, name:str):
    r = cls(decl.doc, rule, name, decl.expr)

class BRVariable(AbstractBRVariable, GBVariable):
  pass

class BRVariableDecl(Decl, cls=BRVariable):
  pass

class BuiltinBRVariable(BRVariable):
  pass

brvariable = BRVariable.decl




class BRule(LabsObject, UseInternal, MetabuildObject):
  """
  Rule for building a step. Translates to a rule in ninja
  """
  _repr_attrs = {'_internal.name': None}
  
  decl_cls:type = None # Assigned by BRuleDecl

  class _Internal(object):
    def __init__(self, parent:BRule, build:LabsBuild, name:str):
      self.build = build
      self.name = name
      self.variables:dict[str, BRVariable] = {}
      self.builtins:dict[str, BuiltinBRVariable] = {}
      map(self.add_variable, (
        BuiltinBRVariable('Command to execute', parent, 'command', None),
        BuiltinBRVariable('Dependencies file in Makefile format (as generated by gcc -MD -MF)', parent, 'depfile', None),
        BuiltinBRVariable('(Ninja-specific) See Ninja documentation. Either gcc ou msvc.', parent, 'deps', None),
        BuiltinBRVariable('Input files', parent, 'in', None),
        BuiltinBRVariable('Output files', parent, 'out', None),
        BuiltinBRVariable('Description (name) of the command', parent, 'description', None),
        BuiltinBRVariable('Ninja-specific, see its documentation', parent, 'msvc_deps_prefix', None),
        BuiltinBRVariable('Ninja-specific, see its documentation', parent, 'description', None),
        BuiltinBRVariable('Ninja-specific, see its documentation', parent, 'dyndep', None),
        BuiltinBRVariable('Ninja-specific, see its documentation', parent, 'generator', None),
        BuiltinBRVariable('Ninja-specific, see its documentation', parent, 'in_newline', None),
        BuiltinBRVariable('Ninja-specific, see its documentation', parent, 'restat', None),
        BuiltinBRVariable('Ninja-specific, see its documentation', parent, 'rspfile', None),
        BuiltinBRVariable('Ninja-specific, see its documentation', parent, 'rspfile_content', None),
      )),

    def add_variable(self, var:BRVariable|BuiltinBRVariable):
      if isinstance(var, BuiltinBRVariable) :
        self.builtins[var.name] = var
      else :
        self.variables[var.name] = var

  def __init__(self, build:LabsBuild, name:str):
    super().__init__(build, name)
    object.__setattr__(self, 'in_', self._internal.builtins['in'])

  def __getattr__(self, key):
    if ret := self._internal.builtins.get(key) :
      return ret
    return self._internal.variables[key]

  def __setattr__(self, key, val):
    if isinstance(val, BRVariableDecl) :
      self._internal.add_variable(val.instanciate(self, key))
    if isinstance(val, Expr) :
      self._internal.add_variable(BRVariable('', self, key, val))
    else :
      raise TypeError(f'BRule can only take BRVariableDecl and Expr as new attributes. Trying to set {repr(val)} for key {key}.')

  __getitem__ = __getattr__
  __setitem__ = __setattr__  
      
  def __contains__(self, key):
    return key in self._internal.builtins or key in self._internal.variables

  @classmethod
  def instanciate(cls, decl, build, name):
    r = cls(build, name)
    build._register_metabuild_object(name, r)
    return r

  @classmethod
  def decl(cls):
    return cls.decl_cls()

class BRuleDecl(Decl, cls=BRule):
  pass

brule = BRule.decl



class BStep(LabsObject, UseInternal, MetabuildObject):
  """
  A build step. Translates to build in ninja
  """
  _repr_attrs = {'_internal.name': None, '_internal.rule':lambda r: r.name}

  class _Internal(object):
    def __init__(self, rule: BRule, name:str):
      self.rule = rule
      self.name = name
      self.overrides:dict[BVariable, Expr] = {}

    @property
    def build(self):
      return self.rule.build

    def get_variable(self, name):
      if name in rule :
        return rule[variable]
      return rule._internal.build._internal.bvariables.get(variable, None)
      
    
  def __init__(self, rule: BRule, name:str):
    super().__init__(rule, name)

  def __getitem__(self, variable:BVariable|str) -> Expr|None:
    if isinstance(variable, str) :
      variable = self._internal.get_variable(variable)
      if not variable :
        raise KeyError(f'No BVariable (global and rule) to overload with name {variable}')
      
    if isinstance(variable, BRVariable) and variable._rule is not self.rule:
      raise ValueError(f'{repr(self)} has no override for {repr(variable)}. Since it is from a different rule, this is most likely a programming mistake.')
    return self._overrides.get(variable, None)

  def __setitem__(self, variable:BVariable|str, override: Expr):
    if isinstance(variable, str) :
      variable = self._internal.get_variable(variable)
      if not variable :
        raise ValueError(f'No BVariable (global and rule) to overload with name {variable}')

    if isinstance(variable, BRVariable) and variable._internal.rule is not self._internal.rule:
      raise ValueError(f'{repr(self)} cannot override {repr(variable)} because it is from a different rule.')
    if override is None :
      del self._overrides[variable]
    else :
      self._overrides[variable] = override

  __getattr__ = __getitem__
  __setattr__ = __setitem__

  @classmethod
  def instanciate(cls, decl, build, name):
    r = cls(decl.rule, name)
    build._register_metabuild_object(name, r)
    return r

  @classmethod
  def decl(cls, rule):
    return cls.decl_cls(rule=rule)

class BStepDecl(Decl, cls=BStep):
  pass

bstep = BStep.decl


