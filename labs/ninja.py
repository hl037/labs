from __future__ import annotations
from pathlib import Path
from .core import Formatter, generator, escape_function
from .variables import Expandable
from .metabuild import BVariable, GBVariable, BRVariable, BuiltinBRVariable, BRule, BStep
from .utils import topological_sort
from typing import TYPE_CHECKING
from . import main

if TYPE_CHECKING :
  from .main import LabsBuild

class MissingCommandInRules(RuntimeError):
  def __init__(self, rules):
    self.rules = rules
    super().__init__(
      'In the following rules, the `command` variable has no value. This is invalid in ninja: ' +
      ', '.join( repr(r) for r in rules )
    )

def scoped_name(var:BVariable):
  if isinstance(var, BRVariable) :
    if isinstance(var, BuiltinBRVariable) :
      return var.name
    return f'_rule_{var.rule._internal.name}_{var.name}'
  return var.name
    

format_ninja_reference = Formatter('ninja_reference', 'nr')

@format_ninja_reference.sub(BVariable)
def _(self:Bvariable):
  return f'${{{scoped_name(self)}}}'

@format_ninja_reference.sub(Expandable)
def _(self:Expandable):
  return self.expanded
  

def bvariable_adj_cb(var:GBVariable):
  expr = var.expr
  return ( p for p in expr.parts if isinstance(p, GBVariable) )


format_ninja = Formatter('ninja', 'n')

@format_ninja.sub(GBVariable)
def _(self:GBVariable):
  if self.expr is None :
    return f'{scoped_name(self)} ='
  else :
    return f'{scoped_name(self)} = {format(self.expr, "nr")}'
  
@format_ninja.sub(BRule)
def _(self:BRule):
  variables = sorted(self._internal.builtins.values(), key=lambda v: v.name)
  variable_txt = ''.join( f'\n  {var:n}' for var in variables if var.expr is not None )
  return f'rule {self._internal.name}{variable_txt}'

def header(build:LabsBuild):
  return f"""
# This file has been generated by the LABS utility from this folder : {build[main.Labs.src_key].value}
# Any change will be overritten by subsequant calls to labs. Editing manually this file generally a bad practice.
"""

@generator('ninja')
def write_ninja(build:LabsBuild):
  out = build._internal.build_path / 'build.ninja'
  objects = build._internal.metabuild_objects.values()
  rules = [ obj for obj in objects if isinstance(obj, BRule) ]
  invalid_rules = [ r for r in rules if r.command.expr is None or not r.command.value ]
  if invalid_rules :
    raise MissingCommandInRules(invalid_rules)
  gbvariables = [ obj for obj in objects if isinstance(obj, GBVariable) ]
  gbvariables.extend( v for r in rules for v in r._internal.variables.values() )
  steps = [ obj for obj in objects if isinstance(obj, BStep) ]

  sorted_variables = topological_sort(sorted(gbvariables, key=lambda v: scoped_name(v)), lambda var: var.dependencies, False)
  sorted_rules = sorted(rules, key=lambda r: r._internal.name)
  sorted_steps = sorted(steps, key=lambda s: s._internal.name)
  with open(out, 'w') as f :
    f.write(header(build))
    f.write('\n\n')
    f.write('\n'.join( format(v, 'ninja') for v in sorted_variables ))
    f.write('\n\n')
    f.write('\n\n'.join( format(r, 'ninja') for r in sorted_rules ))
    f.write('\n\n')
    f.write('\n\n'.join( format(s, 'ninja') for r in sorted_steps ))
    f.write('\n')

@escape_function('ninja', 'ninja_reference')
def escape(s:str):
  return s.replace('$', '$$').replace('\n', '$\n').replace(':', '$:')


