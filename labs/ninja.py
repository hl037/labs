from __future__ import annotations
from pathlib import Path
from .core import Formatter, generator
from .variables import Expandable
from .metabuild import BVariable, GBVariable, BRVariable, BuiltinBRVariable, BRule, BStep
from .utils import topological_sort
from typing import TYPE_CHECKING
from . import main

if TYPE_CHECKING :
  from .main import LabsBuild

def scoped_name(var:BVariable):
  if isinstance(var, BRVariable) :
    if isinstance(self, BuiltinBRVariable) :
      return var.name
    return f'_rule_{var.rule._internal.name}_{var.name})'
  return var.name
    

format_ninja_reference = Formatter('ninja_reference', 'nr')

@format_ninja_reference.sub(BVariable)
def _(self:Bvariable):
  return f'$({scoped_name(self)})'

@format_ninja_reference.sub(Expandable)
def _(self:Expandable):
  return self.expanded
  

def bvariable_adj_cb(var:GBVariable):
  expr = var.expr
  return ( p for p in expr.parts if isinstance(p, GBVariable) )


format_ninja = Formatter('ninja', 'n')

@format_ninja.sub(GBVariable)
def _(self:GBVariable):
  return f'{scoped_name(self)} = {format(self.expr, "nr")}'
  
@format_ninja.sub(BRule)
def _(self:BRule):
  variables = sorted(self._internal.builtins.values(), key=lambda v: v.name)
  variable_txt = ''.join( f'\n  {var:n}' for var in variables )
  return f'rule {self._internal.name}:{variable_txt}'

def header(build:LabsBuild):
  return f"""
# This file has been generated by the LABS utility from this folder : {build[main.Labs.src_key]}
# Any change will be overritten by subsequant calls to labs. Editing manually this file generally a bad practice.
"""

@generator('ninja')
def write_ninja(build:LabsBuild):
  out = build._internal.build_path / 'ninja.build'
  objects = build._internal.metabuild_objects.values()
  rules = [ obj for obj in objects if isinstance(obj, BRule) ]
  gbvariables = [ obj for obj in objects if isinstance(obj, GBVariable) ]
  gbvariables.extend( v for r in rules for v in r._internal.variables.values() )
  steps = [ obj for obj in objects if isinstance(obj, BStep) ]

  sorted_variables = topological_sort(sorted(gbvariables, key=lambda v: scoped_name(v)), lambda var: var.dependencies)
  sorted_rules = sorted(rules, key=lambda r: r.name)
  sorted_steps = sorted(steps, key=lambda s: s.name)
  with open(out, 'w') as f :
    f.write(header(build))
    f.write('\n\n')
    f.write('\n'.join( format(v, 'ninja') for v in sorted_variables ))
    f.write('\n\n')
    f.write('\n\n'.join( format(r, 'ninja') for r in sorted_rules ))
    f.write('\n\n')
    f.write('\n\n'.join( format(s, 'ninja') for r in sorted_steps ))
    f.write('\n')


